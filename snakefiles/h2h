import numpy as np
import matplotlib.pyplot as plt

from itertools import product
from collections import defaultdict
from functools import cache

import cyvcf2
import stdpopsim


wildcard_constraints:
    n=r"\d+",
    i=r"\d+",
    j=r"\d+",


H2H_PARAMS = {
    "models": [
        ("HomSap", stdpopsim.PiecewiseConstantSize(1e4), "pop_0"),
        ("AnoGam", "GabonAg1000G_1A17", "GAS"),
        ("AraTha", "SouthMiddleAtlas_1D17", "SouthMiddleAtlas"),
        ("AraTha", "African3Epoch_1H18", "SouthMiddleAtlas"),
        ("BosTau", "HolsteinFriesian_1M13", "Holstein_Friesian"),
        ("DroMel", "African3Epoch_1S16", "AFR"),
        # ("DroMel", "OutOfAfrica_2L06", "AFR"),
        ("HomSap", "AmericanAdmixture_4B11", "ADMIX"),
        ("HomSap", "Africa_1T12", "AFR"),
        ("HomSap", "Zigzag_1S14", "generic"),
        ("PanTro", "BonoboGhost_4K19", "bonobo"),
        ("PapAnu", "SinglePopSMCpp_1W22", "PAnubis_SNPRC"),
        ("PonAbe", "TwoSpecies_2L11", "Bornean"),
    ],
    "methods": ["smcpp", "phlash", "fitcoal", "msmc2"],
    "limits": {
        "psmc": [1, 10],
        "smcpp": [1, 10],
        "fitcoal": [10, 100],
        "msmc2": [1, 10],
    },
    "sample_sizes": [1, 10, 100],
    "num_replicates": 3,
    "length_multiplier": 1.0,
}


def get_default_mutation_rate(species_name):
    return stdpopsim.get_species(species_name).genome.mean_mutation_rate


def get_genome_length(species_name):
    species = stdpopsim.get_species(species_name)
    return sum(species.get_contig(chrom).length for chrom in get_chroms(species_name))


@cache
def get_truth(species_name, demographic_model, population):
    species = stdpopsim.get_species(species_name)
    mu = get_default_mutation_rate(species_name)
    if isinstance(demographic_model, str):
        model = species.get_demographic_model(demographic_model)
    else:
        model = demographic_model
    md = model.model.debug()
    t_min = 10.0
    t_max = max(1e5, 2 * md.epochs[-1].start_time + 1)
    assert np.isinf(md.epochs[-1].end_time)
    t = np.r_[0.0, np.geomspace(t_min, t_max, 1000)]
    if "::" in population:
        # assume two popualtions, POP1::POP2. (this is very brittle)
        pop1, pop2 = population.split("::")
        pop_dict = {pop1: 1, pop2: 1}
    else:
        pop_dict = {population: 2}
    c, _ = md.coalescence_rate_trajectory(t, pop_dict)
    eta = SizeHistory(t=t, c=c)
    true_dm = DemographicModel(eta=eta, theta=mu, rho=None)
    return true_dm


rule h2h_config_sim:
    output:
        "h2h/model{i}/rep{j}/simulations/params.pkl",
    localrule: True
    run:
        i = int(wildcards.i)
        j = int(wildcards.j)
        species, model, population = H2H_PARAMS["models"][i]
        n = max(H2H_PARAMS["sample_sizes"])
        pop_dict = {population: n}
        seed = j
        params = dict(
            species=species,
            model=model,
            populations=pop_dict,
            seed=seed,
            length_multiplier=H2H_PARAMS["length_multiplier"],
        )
        dump_file(params, output[0])


## PSMC


def input_for_h2h_config_psmc(wc):
    i = int(wc.i)
    species, _, _ = H2H_PARAMS["models"][i]
    n = int(wc.n)
    return [
        "h2h/model{i}/rep{j}/simulations/chr%s.sample%d.psmcfa.gz" % (chrom, j)
        for chrom in get_chroms(species)
        for j in range(n)
    ]


rule h2h_config_for_psmc:
    input:
        input_for_h2h_config_psmc,
    localrule: True
    output:
        "h2h/model{i}/rep{j}/n{n}/psmc/params.pkl",
    run:
        i = int(wildcards.i)
        species, _, _ = H2H_PARAMS["models"][i]
        ret = {}
        ret["mutation_rate"] = get_default_mutation_rate(species)
        ret["input_files"] = input
        dump_file(ret, output[0])


def h2h_chroms_for(wc):
    i = int(wc.i)
    species, _, _ = H2H_PARAMS["models"][i]
    yield from get_chroms(species)


## SMCPP


def input_for_h2h_config_smcpp(wc):
    return [
        r"h2h/model{i}/rep{j}/n{n}/smcpp/chr%s.smc.gz" % chrom
        for chrom in h2h_chroms_for(wc)
    ]


rule h2h_config_for_smcpp:
    input:
        input_for_h2h_config_smcpp,
    output:
        "h2h/model{i}/rep{j}/n{n}/smcpp/params.pkl",
    localrule: True
    run:
        i = int(wildcards.i)
        species, _, _ = H2H_PARAMS["models"][i]
        ret = {}
        ret["mutation_rate"] = get_default_mutation_rate(species)
        ret["input_files"] = input
        dump_file(ret, output[0])


## PHLASH


def input_for_phlash_config(wc):
    ret = {
        "bcf": [
            "h2h/model{i}/rep{j}/simulations/chr%s.bcf" % chrom
            for chrom in h2h_chroms_for(wc)
        ]
    }
    ret["csi"] = [f + ".csi" for f in ret["bcf"]]
    return ret


rule h2h_config_for_phlash:
    input:
        unpack(input_for_phlash_config),
    output:
        r"h2h/model{i}/rep{j}/n{n}/phlash/config.pkl",
    localrule: True
    run:
        def _chrom_size(bcf):
            return cyvcf2.VCF(bcf).seqlens[0]


        chroms_sorted = sorted(input.bfc, key=_chrom_size)
        test_chrom = chroms_sorted[0]
        train_chroms = chroms_sorted[1:]
        n = int(wildcards.n)
        samples = [f"sample{i}" for i in range(n)]
        ret = {}
        ret["test_data"] = (test_chrom, samples)
        ret["train_data"] = [(chrom, samples) for chrom in train_chroms]
        i = int(wildcards.i)
        species, _, _ = H2H_PARAMS["models"][i]
        ret["mutation_rate"] = get_default_mutation_rate(species)
        dump_file(ret, output[0])


## FITCOAL


def input_for_fitcoal_config(wc):
    return [
        "h2h/model{i}/rep{j}/n{n}/chr%s.afs.txt" % chrom for chrom in h2h_chroms_for(wc)
    ]


rule h2h_config_for_fitcoal:
    input:
        input_for_fitcoal_config,
    output:
        params=r"h2h/model{i}/rep{j}/n{n}/fitcoal/params.pkl",
        afs=r"h2h/model{i}/rep{j}/n{n}/fitcoal/afs.txt",
    localrule: True
    run:
        i = int(wildcards.i)
        n = int(wildcards.n)
        species, _, _ = H2H_PARAMS["models"][i]
        L = 0
        afss = []
        for fn in input:
            with open(fn, "rt") as f:
                L += int(next(f).strip())
                afss.append(list(map(int, next(f).strip().split(" "))))
        params = {}
        afs = np.sum(afss, 0)
        with open(output.afs, "wt") as f:
            f.write(" ".join(map(str, afs[1:-1].tolist())))
        params["seed"] = int(wildcards.j)
        params["genome_length_kbp"] = L / 1e3
        params["mutation_rate_per_kb"] = 1e3 * get_default_mutation_rate(species)
        dump_file(params, output.params)


## MSMC2


def input_for_msmc2_config(wc):
    return [
        "h2h/model{i}/rep{j}/n{n}/chr%s.multihetsep.txt" % chrom
        for chrom in h2h_chroms_for(wc)
    ]


rule h2h_config_for_msmc2:
    input:
        input_for_msmc2_config,
    output:
        "h2h/model{i}/rep{j}/n{n}/msmc2/params.pkl",
    localrule: True
    run:
        i = int(wildcards.i)
        species, _, _ = H2H_PARAMS["models"][i]
        ret = {}
        ret["mutation_rate"] = get_default_mutation_rate(species)
        ret["multihet_seps"] = input
        dump_file(ret, output[0])


## PLOTTING


def input_for_h2h_figure(wc):
    i = int(wc.i)
    n = int(wc.n)
    ret = {}
    for method in H2H_PARAMS["methods"]:
        if n in H2H_PARAMS["limits"].get(method, H2H_PARAMS["sample_sizes"]):
            ret[method] = [
                f"h2h/model{i}/rep{j}/n{n}/{method}/estimates.pkl"
                for j in range(H2H_PARAMS["num_replicates"])
            ]
    return ret


rule h2h_figure:
    input:
        unpack(input_for_h2h_figure),
    output:
        r"figures/h2h/model{i}.n{n}.pdf",
    localrule: True
    run:
        T = np.geomspace(1e1, 1e5, 1000)
        i = int(wildcards.i)
        model = H2H_PARAMS["models"][i]
        fig, ax = plt.subplots()
        truth = get_truth(*model)
        ax.plot(T, truth.eta(T, Ne=True), color="black")
        for method, paths in input.items():
            Nes = []
            for path in paths:
                dm = load_file(path)
                if method == "phlash":
                    # list of posterior samples from dm, take posterior median as point estimate
                    Ne = np.median(
                        [d.rescale(truth.theta).eta(T, Ne=True) for d in dm], axis=0
                    )
                else:
                    Ne = dm.rescale(truth.theta).eta(T, Ne=True)
                Nes.append(Ne)
            ax.plot(T, np.mean(Nes, 0), label=method)
        ax.set_xscale("log")
        ax.set_yscale("log")
        ax.legend()
        fig.savefig(output[0])


ALL_OUTPUT.extend(
    [
        f"figures/h2h/model{i}.n{n}.pdf"
        for i in range(len(H2H_PARAMS["models"]))
        for n in H2H_PARAMS["sample_sizes"]
    ]
)
